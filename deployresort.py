# -*- coding: utf-8 -*-
"""Deploy_resortbooking_final.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-dk3GWwgTlXzMawWQU6l1B0wmHOJsQz-
"""

import streamlit as st
import joblib
import pandas as pd
import numpy as np
import datetime
from dateutil.relativedelta import relativedelta
from prophet.make_holidays import make_holidays_df


# Page state control
if "page" not in st.session_state:
    st.session_state.page = "home"

if st.session_state.page == "home":
    # Welcome / Front Slide
    st.markdown("""
<div style='text-align: center;'>
    <h1 style='color: #28a745; font-size: 50px;'>üèñÔ∏è Welcome to the Resort Booking Insights Dashboard</h1>
    <h4 style='color: #a52a2a; font-size: 30px'>Unlock Insights into Peak Seasons, Cancellations, and Occupancy Trends to Boost your Resort's Performance.</h4>
    <br>
    <img src='https://images.unsplash.com/photo-1551918120-9739cb430c6d?q=80&w=1974&auto=format&fit=crop&ixlib=rb-4.1.0&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D' width='950'>
</div>
""", unsafe_allow_html=True)




    st.markdown("---")

    if st.button("‚û°Ô∏è Enter Booking Panel"):
        st.session_state.page = "main"
        st.experimental_rerun()


def convert_yes_no(df):
    return df.applymap(lambda x: {'Yes': 1, 'No': 0}.get(x, 0))


def add_country_freq(df):
    return df.applymap(lambda x: country_freq_map.get(x, 0))

yes_no_cols = ['is_repeated_guest']

country_freq_map = joblib.load(r"C:\Users\HP\resort_booking\country_freq_map.pkl")


# Load multiple models with exception handling
def load_pipelines():
    pipeline = {}
    try:
        pipeline['rf'] = joblib.load(r"C:\Users\HP\resort_booking\rf_pipeline.pkl")
    except Exception as e:
        st.error(f"Error loading Random Forest model: {e}")
        pipeline['rf'] = None
    try:
        pipeline['xgb'] = joblib.load(r"C:\Users\HP\resort_booking\xgb_pipeline.pkl")
    except Exception as e:
        st.error(f"Error loading XGBoost model: {e}")
        pipeline['xgb'] = None
    try:
        pipeline['prophet'] = joblib.load(r"C:\Users\HP\resort_booking\model_prophet.pkl")
    except Exception as e:
        st.error(f"Error loading Prophet model: {e}")
        pipeline['prophet'] = None


    return pipeline

pipeline = load_pipelines()

if st.session_state.page == "main":

    menu = st.sidebar.selectbox("Choose Model",['Peak Seasons Prediction','Cancellation Prediction','Occupancy Forecast'])

    st.markdown("<h1 style='text-align: center; color: #4CAF50;'>üèñÔ∏è RESORT BOOKING INSIGHTS DASHBOARD</h1>", unsafe_allow_html=True)
    if st.button("‚¨ÖÔ∏è Back to Welcome Page"):
        st.session_state.page = "home"
        st.experimental_rerun()
    if menu == 'Peak Seasons Prediction':
            with st.form("peak_form"):
                st.markdown("<h3 style='color:brown;'>üìà Predict Peak Season</h3>", unsafe_allow_html=True)
                st.markdown("<h4 style='text-align: center; color: teal;'>Use this tool to predict whether a given booking falls during a peak season.** This helps optimize pricing, staffing, and inventory based on expected demand.</h4>", unsafe_allow_html=True)

                if pipeline['rf'] is not None:

                        st.header("Enter Booking Details")

                        adults = st.number_input("Adults", min_value=1, max_value=10, value=2)
                        kids = st.number_input("Kids", min_value=0, max_value=10, value=0)
                        newborn = st.number_input("Newborn", min_value=0, max_value=5, value=0)
                        weekend_nights = st.number_input("Weekend Nights", min_value=0, max_value=7, value=1)
                        weekdays_nights = st.number_input("Weekday Nights", min_value=0, max_value=7, value=2)
                        total_time = weekend_nights + weekdays_nights

                        is_repeated_guest = st.selectbox("Is Repeated Guest?", ["Yes", "No"])
                        total_of_special_requests = st.number_input("Special Requests", min_value=0, max_value=5, value=0)

                        booking_month_name = st.selectbox("Booking Month", [
                            'January', 'February', 'March', 'April', 'May', 'June',
                            'July', 'August', 'September', 'October', 'November', 'December'
                        ])
                        booking_day = st.number_input('Booking Day (1-31)', min_value=1, max_value=31, value=15)
                        booking_year = st.number_input('Booking Year', min_value=2000, max_value=2035)

                        # Booking date
                        month_map = {'January': 1, 'February': 2, 'March': 3, 'April': 4, 'May': 5, 'June': 6,
                                     'July': 7, 'August': 8, 'September': 9, 'October': 10, 'November': 11, 'December': 12}
                        booking_month = month_map[booking_month_name]
                        booking_date = datetime.date(booking_year, booking_month, booking_day)

                        reservation_date = st.date_input("Reservation Date", value=datetime.date.today())
                        booking_lead_time = (booking_date - reservation_date).days

                        if booking_lead_time < 0:
                            st.warning("Booking date cannot be before reservation date!")
                            booking_lead_time = 0

                        meal_option = st.selectbox("Meal Type", ["Breakfast", "Lunch", "Dinner", "SC", "Undefined"])
                        reserved_room_type = st.selectbox("Reserved Room Type", ["A", "B", "C", "D", "E", "F", "G", "H", "L"])
                        resort = st.selectbox("Resort Name", ["Beach Resort", "Hill Resort"])
                        country = st.selectbox("Country", ['IND', 'PAK', 'USA', 'ESP', 'IRL', 'SA', 'ROU', 'NOR', 'OMN',
                                                           'ARG', 'POL', 'DEU', 'BEL', 'CHE', 'CN', 'GRC', 'ITA', 'NLD',
                                                           'DNK', 'RUS', 'SWE', 'AUS', 'EST', 'CZE', 'BRA', 'FIN', 'MOZ',
                                                           'BWA', 'LUX', 'SVN', 'ALB', 'CHN', 'MEX', 'MAR', 'UKR', 'SMR'])

                        # Input for model
                        input_df = pd.DataFrame([{
                            'adults': adults,
                            'kids': kids,
                            'newborn': newborn,
                            'booking_month': booking_month,
                            'booking_day': booking_day,
                            'booking_year': booking_year,
                            'is_repeated_guest': 1 if is_repeated_guest == 'Yes' else 0,
                            'total_of_special_requests': total_of_special_requests,
                            'total_time': total_time,
                            'booking_lead_time': booking_lead_time,
                            'meal': meal_option,
                            'reserved_room': reserved_room_type,
                            'resort': resort,
                            'country': country
                        }])
                        # Apply frequency encoding to 'country'
                        input_df['country'] = input_df['country'].map(country_freq_map).fillna(0)

                        submitted = st.form_submit_button(label="Predict",help="Click to make Prediction")
            if submitted:
                prediction = pipeline['rf'].predict(input_df)[0]
                result = 'Peak Season' if prediction == 1 else 'Not Peak Season'
                st.success(f"Prediction: {result}")



    elif menu == 'Cancellation Prediction':
            with st.form("cancel_form"):
                st.markdown("<h3 style='color:brown;'>üìà Predict Cancellation</h3>", unsafe_allow_html=True)
                st.markdown("<p style='text-align: center; color: teal;'>üîç Predict whether a booking is likely to be cancelled and take proactive measures to minimize losses.</p>", unsafe_allow_html=True)


                if pipeline['xgb'] is not None:

                        st.header("Enter Booking Details")


                        adults = st.number_input("Adults", min_value=1, max_value=10, value=2)
                        kids = st.number_input("Kids", min_value=0, max_value=10, value=0)
                        newborn = st.number_input("Newborn", min_value=0, max_value=5, value=0)
                        weekend_nights = st.number_input("Weekend Nights", min_value=0, max_value=7, value=1)
                        weekdays_nights = st.number_input("Weekday Nights", min_value=0, max_value=7, value=2)
                        total_time = weekend_nights + weekdays_nights

                        is_repeated_guest = st.selectbox("Is Repeated Guest?", ["Yes", "No"])
                        total_of_special_requests = st.number_input("Special Requests", min_value=0, max_value=5, value=0)

                        booking_month_name = st.selectbox("Booking Month", [
                            'January', 'February', 'March', 'April', 'May', 'June',
                            'July', 'August', 'September', 'October', 'November', 'December'
                        ])
                        booking_day = st.number_input('Booking Day (1-31)', min_value=1, max_value=31, value=15)
                        booking_year = st.number_input('Booking Year', min_value=2000, max_value=2035)

                        # Booking date
                        month_map = {'January': 1, 'February': 2, 'March': 3, 'April': 4, 'May': 5, 'June': 6,
                                     'July': 7, 'August': 8, 'September': 9, 'October': 10, 'November': 11, 'December': 12}
                        booking_month = month_map[booking_month_name]
                        booking_date = datetime.date(booking_year, booking_month, booking_day)

                        reservation_date = st.date_input("Reservation Date", value=datetime.date.today())
                        booking_lead_time = (booking_date - reservation_date).days

                        if booking_lead_time < 0:
                            st.warning("Booking date cannot be before reservation date!")
                            booking_lead_time = 0

                        meal_option = st.selectbox("Meal Type", ["Breakfast", "Lunch", "Dinner", "SC", "Undefined"])
                        reserved_room_type = st.selectbox("Reserved Room Type", ["A", "B", "C", "D", "E", "F", "G", "H", "L"])
                        resort = st.selectbox("Resort Name", ["Beach Resort", "Hill Resort"])
                        country = st.selectbox("Country", ['IND', 'PAK', 'USA', 'ESP', 'IRL', 'SA', 'ROU', 'NOR', 'OMN',
                                                           'ARG', 'POL', 'DEU', 'BEL', 'CHE', 'CN', 'GRC', 'ITA', 'NLD',
                                                           'DNK', 'RUS', 'SWE', 'AUS', 'EST', 'CZE', 'BRA', 'FIN', 'MOZ',
                                                           'BWA', 'LUX', 'SVN', 'ALB', 'CHN', 'MEX', 'MAR', 'UKR', 'SMR'])

                        # Input for model
                        input_df = pd.DataFrame([{
                            'adults': adults,
                            'kids': kids,
                            'newborn': newborn,
                            'booking_month': booking_month,
                            'booking_day': booking_day,
                            'booking_year': booking_year,
                            'is_repeated_guest': 1 if is_repeated_guest == 'Yes' else 0,
                            'total_of_special_requests': total_of_special_requests,
                            'total_time': total_time,
                            'booking_lead_time': booking_lead_time,
                            'meal': meal_option,
                            'reserved_room': reserved_room_type,
                            'resort': resort,
                            'country': country
                        }])
                        # Apply frequency encoding to 'country'
                        input_df['country'] = input_df['country'].map(country_freq_map).fillna(0)


                        submitted = st.form_submit_button(label="Predict",help="Click to make Prediction")
            if submitted:
                prediction = pipeline['xgb'].predict(input_df)[0]
                result = 'Will Cancel' if prediction == 1 else 'Will not cancel'
                st.success(f"Prediction: {result}")

    elif menu == 'Occupancy Forecast':
        st.markdown("<h3 style='color:brown;'>Occupancy Forecast</h3>", unsafe_allow_html=True)
        st.markdown("<p style='text-align: center; color: darkorange;'>üìà Forecast future occupancy trends to optimize staffing, pricing, and promotions for upcoming months.</p>", unsafe_allow_html=True)

        if pipeline['prophet'] is not None:
            st.info("Select how many months ahead you'd like to forecast occupancy trends.")

            # User input: forecast horizon
            months = st.slider("Forecast Horizon (Months)", min_value=1, max_value=12, value=6)

            # Generate future dataframe

            today = pd.to_datetime(datetime.date.today().strftime('%Y-%m-01'))
            future_dates = pd.date_range(start=today, periods=months, freq='MS')
            # Create a dataframe in Prophet format
            future = pd.DataFrame({'ds': future_dates})

            forecast = pipeline['prophet'].predict(future)
            # --- Monthly Occupancy Trend ---
            forecast[['ds', 'yhat', 'yhat_lower', 'yhat_upper']]
            forecast.rename(columns={'ds': 'Date', 'yhat': 'Occupancy', 'yhat_lower': 'Lower Bound', 'yhat_upper': 'Upper Bound'}, inplace=True)
            forecast['Month']=forecast['Date'].dt.to_period('M')
            monthly_trend = forecast.groupby('Month')['Occupancy'].mean().reset_index()
            monthly_trend['Month'] = monthly_trend['Month'].astype(str)

            st.subheader("Monthly Occupancy Trend")
            st.dataframe(monthly_trend.rename(columns={'Occupancy':'Expected Bookings'}))

            st.subheader("üìã Full Forecast (Daily)")
            st.dataframe(forecast[['Date', 'Occupancy', 'Lower Bound', 'Upper Bound']])


            # --- Peaks and Dips ---
            from scipy.signal import argrelextrema
            import numpy as np

            forecast.rename(columns={'Occupancy': 'Expected Bookings'}, inplace=True)


            # Round Occupancy values
            forecast['Expected Bookings'] = forecast['Expected Bookings'].round(2)
             # Sensitivity (higher = smoother)
            n = 3

            # Find peaks and dips
            peaks = argrelextrema(forecast['Expected Bookings'].values, np.greater_equal, order=n)[0]
            dips = argrelextrema(forecast['Expected Bookings'].values, np.less_equal, order=n)[0]

            peak_dates = forecast.iloc[peaks][['Date', 'Expected Bookings']].copy()
            dip_dates = forecast.iloc[dips][['Date', 'Expected Bookings']].copy()

            # Sort by Occupancy
            peak_dates.sort_values(by='Expected Bookings', ascending=False, inplace=True)
            dip_dates.sort_values(by='Expected Bookings', ascending=True, inplace=True)

            # Display in Streamlit
            st.subheader("üî∫ Expected Occupancy Peaks")
            st.dataframe(peak_dates.reset_index(drop=True))

            st.subheader("üîª Expected Low Booking Periods")
            st.dataframe(dip_dates.reset_index(drop=True))

            from matplotlib import pyplot as plt
            plt.figure(figsize=(12,6))
            plt.plot(forecast['Date'], forecast['Expected Bookings'])
            plt.scatter(peak_dates['Date'], peak_dates['Expected Bookings'], color='red', label='Peaks')
            plt.scatter(dip_dates['Date'], dip_dates['Expected Bookings'], color='green', label='Dips')
            plt.scatter(dip_dates['Date'], dip_dates['Expected Bookings'], color='blue', label='Low Booking Periods')
            plt.grid(True)
            plt.xlabel('Date')
            plt.ylabel('Expected Bookings')
            plt.title('Expected Bookings Forecast with Peaks, Dips, and Low Booking Periods')
            plt.legend()
            plt.show()
            st.pyplot(plt)

            #HOLIDAY TRENDS

            current_year = datetime.date.today().year
            year_list = [current_year + i for i in range(3)]
            holiday_df = make_holidays_df(year_list=year_list, country='IN')

            #Prints holiday df
            st.subheader("üìÖ Upcoming Indian Holidays")
            st.dataframe(holiday_df)

            forecast['Date'] = pd.to_datetime(forecast['Date'])
            forecast['year_month']=pd.to_datetime(forecast['Date']).dt.to_period('M')

            holiday_df['Date'] = pd.to_datetime(holiday_df['ds'])
            holiday_df['year_month']=holiday_df['ds'].dt.to_period('M')
            holiday_month=holiday_df['year_month'].unique()
            forecast['is_holiday_month']=forecast['year_month'].isin(holiday_month).astype(int)
            forecast_with_holidays = forecast.merge(holiday_df[['year_month', 'holiday']],on='year_month',how='left')
            forecast_with_holidays['holiday'].fillna('No Holiday', inplace=True)
            forecast['Holiday']=forecast_with_holidays['holiday']


            import matplotlib.pyplot as plt

            # Create figure
            plt.figure(figsize=(14, 6))

             # Plot forecast line
            plt.plot(forecast['Date'], forecast['Expected Bookings'], label='Forecast', color='skyblue', linewidth=2)

            # Filter holiday months
            holiday_df = forecast[forecast['is_holiday_month'] == 1]

            # Plot holiday points
            plt.scatter(holiday_df['Date'], holiday_df['Expected Bookings'], color='red', label='Holiday Month', zorder=5)

            #To Annotate holiday_name
            for idx, row in holiday_df.iterrows():#iterates through each row .storing idex in idx and each row details in row
                plt.annotate(
                                row['Holiday'],#text that we want to display
                                (row['Date'], row['Expected Bookings']),#Coordinates (x axis=ds, y axis=yhat) to annotate
                                textcoords="offset points",#position the label text slightly offset from the data point
                                xytext=(0, 10),#place text Move 0 units horizontally, 10 points vertically
                                ha='center',#horizonatal alignment of the text to be in the center
                                fontsize=8,
                                rotation=30#angle
                            )

                        # Title and legend
            plt.title('Forecast with Holiday Month Spikes/Dips', fontsize=14)
            plt.xlabel('Date')
            plt.ylabel('Forecasted Value')
            plt.legend()
            plt.grid(True)
            plt.xticks(rotation=45)
            plt.tight_layout()
            plt.show()
            st.pyplot(plt)